#pragma once

#include<iostream> //std::cin, std::cout

#include<vector> //std::vector
#include<string> //std::string
#include<list>	//std::list

#include <functional> //std::hash //optional

typedef int data_type;
typedef std::string key_type;

class HashTable {

	typedef struct {

		key_type key;
		data_type data;

	} table_elem;

	using hash_table = std::vector<std::list<table_elem>>;

private:
	
	hash_table table;

	static const size_t BASE_SIZE;
	static const size_t MAX_CHAIN_SIZE;

public:

	HashTable() : table(BASE_SIZE) {


	}

	//big 4 / 7 ?!
	//the ones generated by the compiler himself
	//will do the trick

public:

	
	//the hash function will be one for all hash tables
	static size_t hashFunction(const key_type&,size_t);


	//basic interface
	void put(const key_type&, const data_type&);

	data_type get(const key_type& key);

	void erase(const key_type& key);

private:

	//helper for re-sizing the hash table
	void rehash();

};

//init the constants
const size_t HashTable::BASE_SIZE = 2;
const size_t HashTable::MAX_CHAIN_SIZE = 3;

size_t HashTable::hashFunction(const key_type& key,const size_t size) {

	//C++ 11 way : 
	/*
	static std::hash<std::string> h_fn;

	return h_fn(key) & (size - 1);
	*/

	//or the trivial string hash function...
	//implemented by us

	size_t result = key.size();

	for (unsigned char c : key)
		result += c;

	//return result % SIZE;
	//but better in case the SIZE is a power of 2
	return result % size;//& (size - 1);

}

void HashTable::put(const key_type& key, const data_type& data) {

	size_t index = hashFunction(key, table.size());
	
	table_elem newElem;
	newElem.key = key;
	newElem.data = data;

	if (table[index].size() >= MAX_CHAIN_SIZE) {

		rehash();
		index = hashFunction(key, table.size());
	}

	table[index].push_front(std::move(newElem));

	std::cout << "stored at hash " << index << std::endl;

}

data_type HashTable::get(const key_type& key) {

	size_t index = hashFunction(key, table.size());

	for (auto elem : table[index]) {

		if (elem.key == key)
			return elem.data;
	}

	throw std::logic_error("there isn't element with such key\n");

}



void HashTable::erase(const key_type& key) {

	size_t index = hashFunction(key, table.size());

	for (auto it = table[index].begin(); it != table[index].end(); ++it) {

		if ((*it).key == key) {
			table[index].erase(it); //erase, not remove !!!
			return;					//it is O(1), because std::list is
									//doubly-linked list
		}

	}

	throw std::logic_error("there isn't element with such key\n");

}

void HashTable::rehash(){

	//debug reasons
	std::cout << "\n...rehashing ...\n";


	//taking all old elements
	hash_table oldTable = std::move(table);

	//in this line our table is empty object
	table.resize(oldTable.size() * 2);

	//for each chain ...
	for (auto list : oldTable)
		for(auto el : list) //for each of its elements
			put(el.key, el.data); //put it in the now table
	//which will lead to re-calculating the hash values

	std::cout << ".............\n";

}
