/*******************************************************************************
 * This file is part of the "Data structures and algorithms" course. FMI 2018/19 
 *******************************************************************************/

/**
 * @file   linear_probing_hash.h
 * @author Ivan Filipov
 * @date   01.2019
 * @brief  Basic implementation of hash table, using
 *         closed hashing (opened address) strategy -
 *         linear probing. 
 *         Depends only on our custom dynamic array.
 * @see https://en.wikipedia.org/wiki/Hash_table
 * @see https://en.wikipedia.org/wiki/Open_addressing
 */

#pragma once

/// toggles debug output. Value of 1 means print debug info, 0 - opposite
#define DEBUG_HASH 1 

#include <string> // std::string

#include "../../dynamic_array/dynamic_array.hpp" // dsa::dynamic_array

//@{
/** for each element we have a key and some data */
typedef std::string key_type;
typedef int data_type;
//@}

/**
 * @class lin_pr_hash_table
 * @brief An associative container that holds key-value pairs.
 *        Provides fast lookups, additions and removals.
 */
class lin_pr_hash_table {
private:
	/**
	 *  @struct table_elem
	 *  @brief  An inner representation of each table element.
	 */ 
	struct table_elem {
		key_type  key  = ""; //!< key
		data_type data = -1; //!< data
	};
	// typedef for easier writing
	// same as typedef dynamic_array<table_elem> hash_table;
	using hash_table = dsa::dynamic_array<table_elem>;

private:
	/* private data members */	
	hash_table table;      //!< the whole table
	size_t logic_fill = 0; //!< how many elements are there
	static const size_t STEP      = 1; //!< step for linear probing. @note gcd(STEP, size) == 1 !!!	
	static const size_t BASE_SIZE = 4; //!< initial size to be allocated. @note small array only with example purpose
public:
	/* object life cycle */
	/** create table with @c BASE_SIZE # of empty objects */
	lin_pr_hash_table(size_t size = BASE_SIZE): table(size, {}) {} 
	// big 4?
	// - > the ones generated by the compiler himself will do the trick
private:
	/* helpers */
	// the hash function will be one for all hash tables
	/**
	 * @brief Calculates the hash for a key.
	 * @param[in] key: compute the hash of that key
	 * @param[in] size: size of a hash table
	 * @retval index in the table in which that key should belong to
	 */
	static size_t hash_func(const key_type& key, size_t size);
	
	/** helper for re-sizing the hash table */
	void rehash();
	
public:
	/* interface */
	/**
	  * @brief     Get an element's data by key.
	  * @param[in] key: the key to be searched.
	  * @retval    data for that key.
	  * @throw     std::logic_error if there is no such key.
	  * 
	  * Time complexity in the best case: O(1),
	  * but linear in elements count in the worst case.
	  */
	data_type get(const key_type& key) const;
	
	/**
	  * @brief     Inserts a key-value pair into %lin_pr_hash_table, if the key is not presenting.
	  * @param[in] key: the key to be inserted.
	  * @param[in] data: data to be inserted.
	  * @throw     std::logic_error if there is already such key inside the hash table.
	  * 
	  * Time complexity in the best case: O(1),
	  * but linear in elements count in the worst case.
	  */
	void insert(const key_type& key, const data_type& data);
	
	/**
	  * @brief     Removes a pair by key from %lin_pr_hash_table, if the key is presenting.
	  * @param[in] key: the key of the pair to be removed.
	  * @throw     std::logic_error if there is not a such key inside the hash table.
	  * 
	  * Time complexity in the best case: O(1),
	  * but linear in elements count in the worst case.
	  */
	void erase(const key_type& key);
	
	/** Prints the content of the hash table */
	void print() const;
};
