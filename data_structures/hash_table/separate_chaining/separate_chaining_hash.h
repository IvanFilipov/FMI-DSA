/*
 * Basic implementation of hash table, using opened hashing strategy -
 * separate chaining. Depends only on our custom dynamic array and custom doubly linked list.
 * This file is part of the "Data structures and algorithms" course. FMI 2018/19
 *
 * Author : Ivan Filipov	
 */

#pragma once

// toggles debug output. Value of 1 means print debug info, 0 - opposite
#define DEBUG_HASH 1 

#include <string> // std::string
#include "../../dynamic_array/dynamic_array.hpp" // dsa::dynamic_array
#include "../../linked_list/doubly_linked_list/dlinked_list.hpp" // dsa::dlinked_list

// predefined key and data types
typedef int data_type;
typedef std::string key_type;

class sp_ch_hash_table {

private:
	// an inner representation of each table element
	struct table_elem {
		key_type  key;
		data_type data;
		table_elem(const key_type& key = "", const data_type& data = -1) :
			key(key), data(data) {}
	};
	// typedef for easier writing
	// same as typedef dynamic_array<dlinked_list<table_elem>> hash_table;
	using hash_table = dsa::dynamic_array<dsa::dlinked_list<table_elem>>;
	// same for internal iterators
	using chain_iter = dsa::dlinked_list<table_elem>::iterator;
private:
	
	/* private data members */
	// the whole table
	hash_table table;
	// initial size to be allocated
	// small array only with example purpose
	static const size_t BASE_SIZE = 2;
	// what is the maximum size of each chain
	static const size_t MAX_CHAIN_SIZE = 3;

public:
	/* object life cycle */
	sp_ch_hash_table(size_t size = BASE_SIZE) : table(size, {}) {} // create table with BASE_SIZE # of empty chains
	//big 4 / 7 ?!
	//the ones generated by the compiler himself
	//will do the trick

private:
	/* helpers */
	// the hash function will be one for all hash tables
	static size_t hash_func(const key_type& key, size_t size);
	// helper for re-sizing the hash table
	void rehash();
	// helper for searching in the linked list
	// returns iterator to the element, end() if not found
	// should be const, but we don't support const_iterator
	// and the syntax will be too compilacted
	chain_iter find(size_t index, const key_type& key);
	
public:
	/* interface */
	// adding new element with his key and data
	void insert(const key_type& key, const data_type& data);
	// get an element by key, should be const, same reason as above
	data_type get(const key_type& key);
	// remove element from the table
	void erase(const key_type& key);
	/// all of above have amortized O(1) best and average case time complexity
	/// but O(MAX_CHAIN_SIZE) in the worst case
	
	// prints the contain of the hash table, should be const, same reason as above
	void print();
};

