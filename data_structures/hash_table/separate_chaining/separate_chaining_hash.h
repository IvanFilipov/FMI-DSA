/*******************************************************************************
 * This file is part of the "Data structures and algorithms" course. FMI 2018/19 
 *******************************************************************************/

/**
 * @file   separate_chaining_hash.h
 * @author Ivan Filipov
 * @date   01.2019
 * @brief  Basic implementation of hash table, using
 *         opened hashing (closed address) strategy -
 *         separate chaining. 
 *         Depends only on our custom dynamic array and doubly linked list.
 * @see https://en.wikipedia.org/wiki/Hash_table
 */

#pragma once

/// toggles debug output. Value of 1 means print debug info, 0 - opposite
#define DEBUG_HASH 1 

#include <string> // std::string

#include "../../dynamic_array/dynamic_array.hpp" // dsa::dynamic_array
#include "../../linked_list/doubly_linked_list/dlinked_list.hpp" // dsa::dlinked_list

//@{
/** for each element we have a key and some data */
typedef std::string key_type;
typedef int data_type;
//@}

/**
 * @class sp_ch_hash_table
 * @brief An associative container that holds key-value pairs.
 *        Provides fast lookups, additions and removals.
 */
class sp_ch_hash_table {
private:
	/**
	 *  @struct table_elem
	 *  @brief  An inner representation of each table element.
	 */ 
	struct table_elem {
		key_type  key;  //!< key
		data_type data; //!< data
		/** Creates a table element by key and data */
		table_elem(const key_type& key = "", const data_type& data = -1) :
			key(key), data(data) {}
	};
	// typedef for easier writing
	// same as typedef dynamic_array<dlinked_list<table_elem>> hash_table;
	using hash_table = dsa::dynamic_array<dsa::dlinked_list<table_elem>>;
	// same for internal iterators
	using chain_iter = dsa::dlinked_list<table_elem>::iterator;
private:
	/* private data members */
	hash_table table;      //!< the whole table
	static const size_t MAX_CHAIN_SIZE = 3; //!< maximum size of each chain.   @note short chains with example purpose only
	static const size_t BASE_SIZE = 2;      //!< initial size to be allocated. @note small array only with example purpose

public:
	/* object life cycle */
	/** create table with @c BASE_SIZE # of empty chains */
	sp_ch_hash_table(size_t size = BASE_SIZE): table(size, {}) {} 
	// big 4?
	// - > the ones generated by the compiler himself will do the trick
private:
	/* helpers */
	// the hash function will be one for all hash tables
	/**
	 * @brief Calculates the hash for a key.
	 * @param[in] key: compute the hash of that key
	 * @param[in] size: size of a hash table
	 * @retval index in the table in which that key should belong to
	 */
	static size_t hash_func(const key_type& key, size_t size);
	
	/** helper for re-sizing the hash table */
	void rehash();
	/**
	 * @brief helper for searching in a linked list
	 * @param[in] index: index of the chain - the list to be searched
	 * @param[in] key: key to be searched for
	 * @retval iterator to the element
	 * @retval iterator to %end(), if an element with that key does not exist.
	 * @note should be const, but we don't support const_iterator
	 *       and the syntax will be too complicated
	 */
	chain_iter find(size_t index, const key_type& key);
	
public:
	/* interface */
	/**
	  * @brief     Get an element's data by key.
	  * @param[in] key: the key to be searched.
	  * @retval    data for that key.
	  * @throw     std::logic_error if there is no such key.
	  * 
	  * Time complexity in the best case: O(1),
	  * but linear in @c MAX_CHAIN_SIZE in the worst case.
	  */
	data_type get(const key_type& key);
	
	/**
	  * @brief     Inserts a key-value pair into %sp_ch_hash_table, if the key is not presenting.
	  * @param[in] key: the key to be inserted.
	  * @param[in] data: data to be inserted.
	  * @throw     std::logic_error if there is already such key inside the hash table.
	  * 
	  * Time complexity in the best case: O(1),
	  * but linear in @c MAX_CHAIN_SIZE in the worst case.
	  */
	void insert(const key_type& key, const data_type& data);
	
	/**
	  * @brief     Removes a pair by key from %sp_ch_hash_table, if the key is presenting.
	  * @param[in] key: the key of the pair to be removed.
	  * @throw     std::logic_error if there is not a such key inside the hash table.
	  * 
	  * Time complexity in the best case: O(1),
	  * but linear in elements count in the worst case.
	  */
	void erase(const key_type& key);
	
	/** Prints the content of the hash table */
	void print();
};
